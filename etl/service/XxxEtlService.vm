#parse("include/var_entity.vm")

/**
* Copyright Â© 2016 MIMOS Berhad. All Rights Reserved 
*
* All intellectual properties not limited to patents, trademarks, industrial designs,
* copyrights, know-how including layout of images and contents contained herein 
* belong to MIMOS Berhad. Any reproduction, modification, distribution 
* or republishing materials without prior written consent is prohibited.
*   
* Class name: my.mimos.tpcohcis.report.ohcis.pg101.etl.service.Pg101ETLService
* Description: 
* <TODO: What the class does>
* 
*/

package my.mimos.tpcohcis.report.nontpchims.${entityInstance}.etl.service;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.sql.Timestamp;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.Calendar;
import java.util.Date;
import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.Query;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import my.mimos.tpcohcis.DataETL;
import my.mimos.tpcohcis.report.nontpchims.${entityInstance}.generate.model.${entityClass};
import my.mimos.tpcohcis.report.nontpchims.${entityInstance}.generate.model.${entityClass}SourceRegister;
import my.mimos.tpcohcis.report.nontpchims.${entityInstance}.generate.repository.${entityClass}Repository;
import my.mimos.tpcohcis.report.nontpchims.${entityInstance}.generate.repository.${entityClass}SourceRegisterRepository;
import my.mimos.tpcohcis.report.shared.util.ReportUtil;
import my.mimos.tpcohcis.shared.util.DateUtil;

@Service
public class ${entityClass}EtlService implements DataETL {
  private static final Logger LOGGER = LoggerFactory.getLogger(${entityClass}EtlService.class);

    @Autowired
    ${entityClass}Repository ${entityInstance}Repository;
    
    @PersistenceContext
    private EntityManager entityManager;

    @Autowired
    private ${entityClass}SourceRegisterRepository ${entityInstance}SourceRegisterRepo;

    @Value("$${startbrace}report.configuration.fetchsize${endbrace}")
    private Integer maxFetchSize;
	
    @Override
    public void doETL(LocalDateTime startDate, LocalDateTime endDate) {
	
	StringBuilder strBody=new StringBuilder();
	strBody.append("  from trx_cd_episode_diagnosis  ed"   // TODO
	    + " inner join trx_pm_patient_visit v on ed.patient_visit_id = v.visit_id"
	    + " inner join mst_pm_patient p on ( v.patient_id = p.patient_id)"
	    + " inner join mst_am_facility f on (v.clinic_id = f.facility_id)"
	    + " left outer join mst_am_facility_address fa on f.facility_id = fa.facility_id"
	    + " left outer join  ref_co_state sta on fa.state_id=sta.state_id"
	    + " left outer join  ref_co_district dst on fa.district_id=dst.district_id"
	    + " left outer join trx_pm_death_information di on p.patient_id = di.patient_id"
	    + " WHERE 1=1"
	    + " and ( ed.diagnosis_code like 'A0%' or di.immediate_course_of_death like 'A0%') "
	    + " AND ed.episode_diagnosis_id not in (select r.episode_diagnosis_id from report.rpt_nontpchims_${entityInstance}_src_registry r , trx_cd_episode_diagnosis ci where ci.episode_diagnosis_id = r.episode_diagnosis_id "
	    + " and ((ci.updated_at is not null AND ci.updated_at = r.updated_at) or (ci.updated_at is null AND ci.created_at = r.updated_at))) "
	    );
	
	StringBuilder strCount=new StringBuilder();
	strCount.append("select count(*) " + strBody);
	
	StringBuilder strQuery=new StringBuilder();

	// TODO
	strQuery.append("SELECT"
	    + " sta.state_name as state,"
	    + " dst.district_name as district,"
	    + " f.facility_name as unit,"
	    + " sta.state_id,"
	    + " dst.district_id,"
	    + " p.patient_id,"
	    + " ed.diagnosis_code,"
	    + " ed.date_diagnosed,"
	    + " ed.episode_diagnosis_id,"
	    + " ed.created_at,"
	    + " ed.updated_at,"
	    + " p.date_of_birth,"
	    + " di.death_date,"
	    + " f.facility_id"
	    + strBody 
	    + " order by 1,2,3" );
	

	LOGGER.info("strCount is "+ strCount.toString());
	LOGGER.info("strQuery is "+ strQuery.toString());
	
	long totalRecords=0;
	Query queryTot = entityManager.createNativeQuery(strCount.toString());
	BigInteger cResult = (BigInteger) queryTot.getSingleResult();
	if (cResult != null) {
	  totalRecords = cResult.longValue();
	}
	
	int processedRecords=0;
	while(processedRecords < totalRecords){
	  Query query = entityManager.createNativeQuery(strQuery.toString());
	  query.setFirstResult(0);
	  query.setMaxResults(maxFetchSize);
	  
	  List<Object[]> listResult = (List<Object[]>) query.getResultList();
	  
	  Timestamp createdAt= null;
	  Timestamp updatedAt= null;
	  for (Object[] obj : listResult) {
	      	${entityClass} nhph= new ${entityClass}();

				#foreach($field in $entity.nonKeyAttributes)
				#if ($field.setter)    
					nhph.${field.setter}(get${field.type}(obj[${velocityCount}]));
				#end
				#end 			
				/*		
	      	nhph.setStateName(getString(obj[0]));
	      	nhph.setDistrictName(getString(obj[1]));
	      	nhph.setFacilityName(getString(obj[2]));
	      	nhph.setStateId(getLong(obj[3]));
	      	nhph.setDistrictId(getLong(obj[4]));
	      	nhph.setPatientId(getLong(obj[5])); 
	      	nhph.setDiagnoseCode(getString(obj[6]));//count diagnosisCode as OPD attendance
	      	nhph.setDiagnoseDate(getDate(obj[7]));
	      	nhph.setEpisodeDiagnosisId(getLong(obj[8]));    	
	      	
	      	createdAt= getTimestamp(obj[9]);
	      	updatedAt= getTimestamp(obj[10]);
	      	nhph.setBirthDate(getDate(obj[11]));
	      	nhph.setDeathDate(getDate(obj[12]));
	      	nhph.setFacilityId(getLong(obj[13]));
					*/
	      	${entityInstance}Repository.save(nhph);
		    
		${entityClass}SourceRegister nhph003SourceRegistr = ${entityInstance}SourceRegisterRepo.findOne(nhph.getEpisodeDiagnosisId());
		if(nhph003SourceRegistr == null) {
		  nhph003SourceRegistr = new ${entityClass}SourceRegister();
		  nhph003SourceRegistr.setEpisodeDiagnosisId(nhph.getEpisodeDiagnosisId());
		} 
		if(updatedAt != null){
		  nhph003SourceRegistr.setUpdatedAt(updatedAt );
		} else {
		  nhph003SourceRegistr.setUpdatedAt(createdAt);
		}
		${entityInstance}SourceRegisterRepo.save(nhph003SourceRegistr);
		    
	    }
	  processedRecords++;
	}

    }
        
    private String getString(Object object) {
	String result = "";
	if (null != object && object.getClass().getClass().isInstance(String.class)) {
	    result = object.toString();
	}
	return result;
  }

  private Date getDate(Object object) {
	Date result = null;
	if (null != object && object instanceof LocalDate) {
	    result = (Date) object;
	} else if (null != object && object instanceof Date) {
	    result = (Date) object;
	}
	return result;
  }

  private Long getLong(Object object) {
	Long result = 0L;
	if (null != object && object instanceof BigDecimal) {
	    result = ((Number) object).longValue();
	} else if (null != object && object instanceof BigInteger) {
	    BigInteger resulti = (BigInteger) object;
	    result = resulti.longValue();
	} else if (null != object && object instanceof Integer) {
	    Integer resulti = (Integer) object;
	    result = resulti.longValue();
	}
	return result;
  }
  
  private Timestamp getTimestamp(Object object) {
	Date result = null;
	if (null != object && object instanceof LocalDate) {
	   result = (Date) object;
	} else if (null != object && object instanceof Date) {
	    result = (Date) object;
	}
	Timestamp ts= null;
	if(null != result){
	    ts = new Timestamp(result.getTime());
	}
	return ts;
  }   
    private Integer getMonth(Date date){
	Calendar cal = Calendar.getInstance();
	cal.setTime(date);
	return cal.get(Calendar.MONTH);
  }

  private Integer getYear(Date date){
	Calendar cal = Calendar.getInstance();
	cal.setTime(date);
	return cal.get(Calendar.YEAR);
  }

  @Override
  public String getReportCode() {
    return "${entityCaps}";
  }

}
